Get["mc-boo-para.m"];

it=4;prec=100;nzCheck=100;seed=123;minops=4;maxops=5;
(*minors per processor*)
nmin=20;
(*processors*)
nProcs=2;
(*Run parameters*)
(*Iterations for the first run, the one in which all operators vary*)
firstNit=10;
(*Iterations for each successive run. This can be overridden by defining manually the array nits*)
succNits=5;
(*Relative detuning for the first operators (the ones varied in the first iteration). 1 is exact dimensions.*)
firstOffset=15/10;
(*Relative detuning for the successive operators. 1 is exact dimensions.*)
succOffset=11/10;
(*sigma for the NoV minimization MC. deprecated after we started working with a big number of z points*)
sigmaChi=1/100;

(*sigma for the distribution of points of logdet MC*)
sigmaz=1;
idTag="sumtests";
(*sigma for the a posteriori check*)
sigmazCheck=1;
(*sigma for the a posteriori check*)
sigmaMC=1/10;
(*number of repetitions of a given step when the a posteriori check is not satisfied*)
maxReps=0;
(*dcross regularization. Hasn't been updated for the parallel routine. Please contact the developers if you want to set a value different from 0*)
dcross=0;

elems=Table[Table[Range[1+(opa+1)j-(opa+1),(opa+1)j],{j,1,nmin}],{opa,minops,maxops}];
Nz=Table[nmin(opa+1),{opa,minops,maxops}];
ΔL=deltaFree[maxops];sigmazLogdet=Table[sigmaz,{opa,minops,maxops}];
opsToVary=Table[Range[1,opa],{opa,minops,maxops}];
nits=ConstantArray[succNits,maxops-minops+1];sigmaChiList=Table[sigmaChi,{i,minops,maxops}];
βlist=Table[2/5,{i,minops,maxops}];
ΔL[[1;;minops,1]]=ΔL[[1;;minops,1]] (firstOffset);
ΔL[[minops+1;;maxops,1]]=ΔL[[minops+1;;maxops,1]] (succOffset);
nits[[1]]=firstNit;
mcIteratorSplitThing[it,1,0,minops,maxops,ΔL,βlist,nzCheck,prec,seed,nits,idTag,sigmazCheck,sigmaMC,maxReps,sigmaChiList,opsToVary,sigmazLogdet,Nz,elems,dcross,nProcs];
mcIteratorSplitThing[it+1,1,0,minops,maxops,ΔL,βlist,nzCheck,prec,seed,nits,idTag,sigmazCheck,sigmaMC,maxReps,sigmaChiList,opsToVary,sigmazLogdet,Nz,elems,dcross,nProcs]
